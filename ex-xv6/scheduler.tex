%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[18pt]{extarticle}

\input{structure.cls} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Χρόνο-προγραμματισμός Διεργασιών στο \src{xv6} Kernel \\Λειτουργικά Συστήματα (ECE ΓΚ702)} % Title of the assignment

\author{\footnotesize Χρήστος Φείδας\\ \footnotesize \src{fidas@upatras.gr} \and \footnotesize Ευάγγελος Λάμπρου\\ \footnotesize \src{e.lamprou@upnet.gr}} % Author name and email address

\date{University of Patras --- \the\year{}} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------
\bibliography{bibliography}

\begin{document}

\pagestyle{fancy}
%... then configure it.
\fancyhf{} % sets both header and footer to nothing
\renewcommand{\headrulewidth}{0pt}
\fancyhead{} % clear all header fields
\fancyfoot{} % clear all footer fields
\fancyfoot[L]{\footnotesize Χρήστος Φείδας, \footnotesize Ευάγγελος Λάμπρου}
\fancyfoot[R]{\thepage}

\maketitle

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section{Εισαγωγή}

Ο χρονοπρογραμματισμός διεργασιών είναι μία από τις σημαντικότερες 
αρμοδιότητες ενός λειτουργικού συστήματος.
Στόχος είναι η κάθε διεργασία να \say{νομίζει} πως έχει ένα 
δικό της CPU στο οποίο εκτελούνται σειριακά οι εντολές της.
Αν αυτό ήταν αλήθεια βέβαια, θα χρειαζόμασταν $n$ επεξεργαστικές μονάδες 
για να εκτελέσουμε $n$ διεργασίες ταυτόχρονα στον υπολογιστή μας. 
Μέσω της πολύπλεξης διεργασιών γίνεται να φαίνεται πως τρέχουν ταυτόχρονα στον υπολογιστή μας
πολύ περισσότερες διεργασίες απ'ότι οι πυρήνες που κατέχει το σύστημά μας.

Στο xv6 η πολύπλεξη αυτή γίνεται με την CPU να εναλλάσεται από τη μία διεργασία
στην άλλη σε περιπτώσεις
\begin{enumerate*}
    \item Μηχανισμός sleep και wake \cite{OnlineSleepWake}.
    \item CPU time interrupt σε περίπτωση που μία διεργασία εκτελείται για μεγάλο χρονικό διάστημα.
\end{enumerate*}

Εδώ φαίνεται πως το λειτουργικό σύστημα δεν είναι απλά ένα πρόγραμμα το οποίο εκτελείται σειριακά στον επεξεργαστή, 
αλλά ένα σύστημα το οποίο αξιοποιεί λειτουργίες του υλικού (interrupts) για να επανέρχεται σε εκτέλεση, διακόπτωντας
την τώρα εκτελούμενη διεργασία και επιστρέφοντας σε αυτήν όταν πρέπει.

\section{Context Switching}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{assets/sched/switch.png}
    \caption{Context switch από μία διεργασία χρήστη (\src{shell}) 
    προς μία ρουτίνα πυρήνα (\src{scheduler}) και τελικά 
    σε μία άλλη διεργασία χρήστη (\src{cat}).}
\end{figure}

Μία προσιτή εισαγωγή στο μηχανισμό context switching του επεξεργαστή μπορείτε 
να βρείτε \href{https://cpu.land/slice-dat-time}{εδώ}.

\section{Scheduler}

Ο χρονοπρογραμματιστής (scheduler) είναι το κομμάτι του κώδικα του πυρήνα το οποίο 
είναι υπεύθυνο στο διαμερισμό του χρόνου του επεξεργαστή ανάμεσα στις ενεργές διεργασίες
του συστήματος. Ο σχεδιασμός ενός scheduler πρέπει να λάβει πολλά πράγματα υπόψιν
όπως η ταχύτητα, το είδος του φόρτου εργασίας που θα δέχεται το σύστημα στο οποίο τρέχει
(π.χ. ένας υπολογιστής οικιακής χρήσης πιθανότατα θα έχει διαφορετικές ανάγκες από έναν server), 
ακόμα και κατανάλωση ενέργειας. Μία σύντομη αναδρομή της ιστορίας του scheduler στο Linux Kernel
μπορείτε να βρείτε \href{https://dev.to/satorutakeuchi/a-brief-history-of-the-linux-kernel-s-process-scheduler-the-very-first-scheduler-v0-01-9e4}{εδώ} και \href{https://www.youtube.com/watch?v=XpFWPgofFR8}{εδώ (βίντεο)}.

\section{Προετοιμασία}

Θα συνεχίσετε πάνω στον πηγαίο κώδικα της προηγούμενης εργασίας. 
Για αρχή, ενώ είστε μέσα στο φάκελο \src{xv6}, εκτελέστε τις παρακάτω \src{git} εντολές
ώστε να φτιάξετε ένα νέο branch πάνω στο οποίο θα κάνετε τις νέες αλλαγές. Αυτό 
θα το κάνει εύκολο να πάτε πίσω στο αρχικό branch σε περίπτωση λαθών.

\begin{commandline}
\begin{verbatim}
$ git chechout -b scheduling 
\end{verbatim}
\end{commandline}

\subsection{Προτεινόμενο Διάβασμα}

\begin{itemize}

    \item Διαβάστε από το βιβλίο του xv6 \cite{xv6Book} το κεφάλαιο 5 (\textit{Scheduling})
    \item Δείτε το επεξηγηματικό \href{https://www.youtube.com/watch?v=-O_JX5mMMHY}{βίντεο} για μία λεπτομερή παρουσίαση της διαδικασίας scheduling στο xv6.

\end{itemize}

\section{Ασκήσεις}

\begin{question}
    Πώς αναπαρίσταται μία διεργασία στο xv6 kernel;
    Εξηγήστε τη σημασία καθενός από τα members του struct 
    το οποίο αντιπροσωπεύει μία διεργασία στο σύστημα.

    \begin{info}[Σημείωση:]
        Κοιτάξτε στο αρχείο \src{kernel/proc.h}.
    \end{info}
\end{question}

\begin{question}
    Ποια είναι η συνάρτηση \src{scheduler}, ποια είναι η συνάρτηση \src{sched}. Εξηγήστε τη λειτουργία της καθεμίας.
\end{question}

\begin{question}
    Τροποποιήστε το xv6 kernel ώστε να υποστηρίζει την πολιτική προγραμματισμού Lottery Scheduling \cite{OSTEP-SchedLottery, LotteryScheduling1994}

    Το Lottery Scheduling θα λειτουργεί ως εξής:

    Μία διεργασία θα ξεκινά την εκτέλεσή της με ένα συγκεκριμένο αριθμό εισητηρίων (\src{tickets}), αυτό μπορεί να είναι ένας οποιοδήποτε αριθμός θέλετε.
    Ο scheduler κάνει μια κλήρωση για την κάθε διεργασία. Αν κάποια από αυτές \say{κερδίσει}, θα ξεκινήσει η εκτέλεσή της.
    Αυτή η διαδικασία θα επαναλαμβάνεται για κάθε κλήση στον scheduler.

    Ο αριθμός εισητηρίων μιας διεργασίας μπορεί να αλλάξει με τη χρήση της system call \src{settickets(int n)} που θα πρέπει να υλοποιήσετε.
    Όταν ο χρήστης εκτελεί αυτή τη system call, η τρέχουσα διεργασία θα αλλάζει αριθμό εισητηρίων με βάση το όρισμα. Η τρέχουσα διεργασία 
    που εκτελείται στον τρέχοντα πυρήνα (core) βρίσκεται στην global μεταβλητή \src{proc} μέσα στο kernel.

    Τη διαδικασία της κλήρωσης μπορείτε να την υλοποιήσετε με διάφορους τρόπους.
    Ο αλγόριθμος που επιλεξετε πρέπει να έχει τις παρακάτω ιδιότητες:
    \begin{itemize}
        \item \textbf{Δικαιοσύνη (Fairness):} Κάθε διεργασία πρέπει να έχει
            πιθανότητα επιλογής ανάλογη με τον αριθμό των εισητηρίων που
            κατέχει. Περισσότερα εισητήρια σημαίνει μεγαλύτερη πιθανότητα να
            επιλεγεί.
        \item \textbf{Αποδοτικότητα (Efficiency):} Ο αλγόριθμος πρέπει να είναι
            αρκετά γρήγορος ώστε να μην καθυστερεί την εκτέλεση του συστήματος.
            Η διαδικασία της κλήρωσης πρέπει να είναι απλή και να εκτελείται
            γρήγορα με κάθε κλήση του scheduler.
        \item \textbf{Αναλογικότητα (Proportionality):} Ο αλγόριθμος πρέπει να
            διασφαλίζει ότι η πιθανότητα να εκτελεστεί μια διεργασία είναι
            ανάλογη με τον αριθμό εισητηρίων που έχει. Αυτό σημαίνει ότι αν μια
            διεργασία Α έχει διπλάσια εισητήρια από μια διεργασία Β, θα πρέπει
            να έχει διπλάσια πιθανότητα να επιλεγεί.
    \end{itemize}


    Θα χρειαστεί επίσης να προσθέσετε μία \href{https://wiki.osdev.org/Random_Number_Generator#Pseudorandom_number_generators}{γεννήτρια τυχαίων αριθμών}
    στο kernel.

    Για να καταλάβετε αν λειτουργεί σωστά ο scheduler σας μπορείτε να χρησιμοποιήσετε 
    το έτοιμο πρόγραμμα \src{sched-test}. Αυτό θα σας δώσει στατιστικά σχετικά με το χρόνο εκτέλεσης 
    της κάθε διεργασίας. Εξηγήστε γιατί η υλοποίησή σας είναι σωστή με βάση τα αποτελέσματα.
    Επεξεργαστείτε τον κώδικα στο αρχείο \src{user/sched-test.c} αλλάζωντας τον αριθμό των εισητηρίων 
    που δίνονται στην κάθε διεργασία. Εξηγήστε τα αποτελέσματα της εκτέλεσης.

    \begin{info}[Βοήθεια:]
        Τα σημεία του πηγαίου κώδικα που θα πρέπει να επεξεργαστείτε είναι τα εξής: 
        
        \begin{itemize}
            \item Συνάρτηση \src{scheduler} στο αρχείο \src{kernel/proc.c} ώστε να γίνεται η επιλογή της διεργασίας που θα εκτελεστεί σε κάθε κβάντο με βάση τον νικητή της κλήρωσης.
            \item Συνάρτηση \src{fork} στο αρχείο \src{kernel/proc.} μπορείτε να έχετε μία διεργασία να κληρονομεί τα εισητήρια από το γονέα της.
            \item Τα αρχεία \src{kernel/sysproc.c}, \src{kernel/syscall.c}, \src{include/sysproc.h}, \src{include/user.h}, \src{ulib/usys.S} 
                για την προσθήκη της απαραίτητης κλήσης συστήματος ώστε να ελέγχεται ο αριθμός εισητηρίων μιας διεργασίας από κώδικα χρήστη.
            \item Συμπληρώστε τον κατάλληλο κώδικα στο αρχείο \src{include/random.h} για την υλοποίηση της γεννήτριας τυχαίων αριθμών.
        \end{itemize}

        Φροντίστε να δώσετε στην διεργασία \src{init} (PID 1) ένα τουλάχιστον εισητήριο.
    \end{info}

\end{question}

\printbibliography

\end{document}
